<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS2 Skin Workshop Tool</title>
    <!-- Tailwind CSS para UI rápida e bonita -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Body com scroll condicional: fixo no desktop, scroll no mobile */
        body { margin: 0; background-color: #09090b; color: white; }
        
        canvas { touch-action: none; }
        /* Cursor customizado para o canvas 2D */
        #textureCanvas { cursor: crosshair; }
        
        /* Scrollbar customizada */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #18181b; }
        ::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #52525b; }
    </style>
    <!-- Import Map para Three.js (Versão Estável) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<!-- Ajuste na classe do body para permitir scroll no mobile (overflow-y-auto) e travar no desktop (md:overflow-hidden) -->
<body class="flex flex-col h-screen font-sans antialiased overflow-y-auto md:overflow-hidden">

    <!-- HEADER -->
    <header class="h-14 bg-zinc-950 border-b border-zinc-800 flex items-center justify-between px-4 md:px-6 flex-shrink-0 z-20 sticky top-0 md:relative w-full">
        <div class="flex items-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-500"><polygon points="12 2 2 7 12 12 22 7 12 2"/></svg>
            <h1 class="font-bold tracking-wider text-base md:text-lg whitespace-nowrap">CS2 <span class="text-yellow-500">WORKSHOP</span></h1>
        </div>
        <div class="flex items-center gap-2 md:gap-4 text-xs md:text-sm text-zinc-400">
            <span class="flex items-center gap-1 hidden sm:inline" id="weaponLabel">AK-47 (Preview)</span>
            <span class="w-px h-4 bg-zinc-700 hidden sm:inline"></span>
            <span class="flex items-center gap-1 whitespace-nowrap">1024px</span>
        </div>
    </header>

    <!-- CONTAINER PRINCIPAL: Flex-col no mobile, Flex-row no desktop (md) -->
    <div class="flex-1 flex flex-col md:flex-row overflow-visible md:overflow-hidden">
        
        <!-- SIDEBAR DE FERRAMENTAS: Full width no mobile, 72px no desktop -->
        <aside class="w-full md:w-72 bg-zinc-900 border-b md:border-b-0 md:border-r border-zinc-800 flex flex-col p-4 gap-6 shrink-0 z-10 shadow-lg order-last md:order-first h-auto md:h-full overflow-y-auto">
            
            <!-- Seleção de Arma Integrada -->
            <section class="bg-zinc-800 p-3 rounded-lg border border-zinc-700 space-y-3">
                <div>
                    <label class="text-xs font-bold text-zinc-400 uppercase mb-2 block">Modelo Base (Procedural)</label>
                    <select id="weaponSelect" class="w-full bg-zinc-900 text-white text-sm p-2 rounded border border-zinc-600 focus:outline-none focus:border-yellow-500 cursor-pointer">
                        <option value="ak47">AK-47</option>
                        <option value="m4a1s">M4A1-S (Silenciador)</option>
                        <option value="awp">AWP (Sniper)</option>
                        <option value="glock">Glock-18</option>
                        <option value="deagle">Desert Eagle</option>
                    </select>
                </div>
                
                <div class="border-t border-zinc-700 pt-3">
                    <label class="text-xs font-bold text-yellow-500 uppercase mb-2 block flex items-center gap-2 cursor-pointer hover:text-yellow-400 transition-colors" onclick="document.getElementById('fileInput').click()">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                        Carregar Modelo 3D
                    </label>
                    <p class="text-[10px] text-zinc-500 mb-2">Suporta: .OBJ, .GLTF, .GLB</p>
                    <input type="file" id="fileInput" accept=".obj,.gltf,.glb" class="hidden">
                </div>
            </section>

            <!-- Ferramentas -->
            <section>
                <label class="text-xs font-bold text-zinc-500 uppercase mb-3 block">Ferramentas de Pintura</label>
                <div class="grid grid-cols-2 gap-2">
                    <button id="btnBrush" class="flex items-center justify-center gap-2 p-3 rounded transition-colors bg-yellow-600 text-white font-medium text-sm">
                        Pincel
                    </button>
                    <button id="btnEraser" class="flex items-center justify-center gap-2 p-3 rounded transition-colors bg-zinc-800 hover:bg-zinc-700 text-zinc-200 font-medium text-sm">
                        Borracha
                    </button>
                </div>
            </section>

            <!-- Cor -->
            <section>
                <label class="text-xs font-bold text-zinc-500 uppercase mb-3 block">Cor</label>
                <div class="flex gap-2 mb-2 flex-wrap">
                    <button class="color-preset w-8 h-8 rounded-full border border-zinc-700 hover:scale-110 transition-transform" style="background-color: #ff0000;" data-color="#ff0000"></button>
                    <button class="color-preset w-8 h-8 rounded-full border border-zinc-700 hover:scale-110 transition-transform" style="background-color: #00ff00;" data-color="#00ff00"></button>
                    <button class="color-preset w-8 h-8 rounded-full border border-zinc-700 hover:scale-110 transition-transform" style="background-color: #0000ff;" data-color="#0000ff"></button>
                    <button class="color-preset w-8 h-8 rounded-full border border-zinc-700 hover:scale-110 transition-transform" style="background-color: #ffff00;" data-color="#ffff00"></button>
                    <button class="color-preset w-8 h-8 rounded-full border border-zinc-700 hover:scale-110 transition-transform" style="background-color: #ffffff;" data-color="#ffffff"></button>
                    <button class="color-preset w-8 h-8 rounded-full border border-zinc-700 hover:scale-110 transition-transform" style="background-color: #000000;" data-color="#000000"></button>
                </div>
                <input type="color" id="colorPicker" value="#ff0000" class="w-full h-10 bg-zinc-800 rounded cursor-pointer border-none p-1">
            </section>

            <!-- Tamanho -->
            <section>
                <div class="flex justify-between mb-1">
                    <label class="text-xs font-bold text-zinc-500 uppercase">Tamanho</label>
                    <span id="sizeValue" class="text-xs text-zinc-400">20px</span>
                </div>
                <input type="range" id="sizeSlider" min="1" max="100" value="20" class="w-full h-2 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-yellow-500">
            </section>

            <!-- Desgaste (Simulação 3D) -->
            <section class="pt-4 border-t border-zinc-800">
                <div class="flex justify-between mb-1">
                    <label class="text-xs font-bold text-zinc-500 uppercase">Desgaste (Float)</label>
                    <span id="wearValue" class="text-xs text-zinc-400">0.05</span>
                </div>
                <input type="range" id="wearSlider" min="0" max="1" step="0.01" value="0.05" class="w-full h-2 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-green-500">
                <p class="text-[10px] text-zinc-600 mt-1">Simula Factory New → Battle Scarred</p>
            </section>

            <div class="mt-auto pt-4">
                <button id="btnExport" class="w-full py-3 bg-zinc-100 text-black font-bold rounded hover:bg-zinc-300 transition-colors flex items-center justify-center gap-2 shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    EXPORTAR .PNG
                </button>
            </div>
        </aside>

        <!-- ÁREA CENTRAL: Flex-col no mobile, Flex-row no desktop largo (lg) -->
        <main class="flex-1 flex flex-col lg:flex-row bg-zinc-950 relative overflow-visible md:overflow-hidden">
            
            <!-- EDITOR 2D -->
            <!-- w-full no mobile, w-1/2 no desktop. Altura automática no mobile -->
            <div class="w-full lg:w-1/2 p-4 md:p-6 flex flex-col items-center justify-center border-b lg:border-b-0 lg:border-r border-zinc-800 bg-zinc-900 relative shrink-0">
                <div class="absolute inset-0 opacity-10 pointer-events-none" style="background-image: radial-gradient(#333 1px, transparent 1px); background-size: 20px 20px;"></div>
                
                <div class="mb-2 w-full max-w-[500px] flex justify-between text-xs text-zinc-500 font-mono uppercase z-10">
                    <span>Editor de Textura (UV Map)</span>
                    <span class="text-yellow-600 animate-pulse hidden" id="savingIndicator">Salvando...</span>
                </div>
                
                <!-- RESPONSIVIDADE CANVAS: w-full e aspect-square em vez de px fixo -->
                <div class="relative shadow-2xl border border-zinc-700 bg-zinc-800 z-10 w-full max-w-[500px] aspect-square">
                    <canvas id="textureCanvas" width="1024" height="1024" class="w-full h-full bg-white"></canvas>
                </div>
                
                <div class="mt-4 text-xs text-zinc-600 text-center max-w-md z-10 hidden sm:block">
                    Dica: Desenhe sobre o quadrado acima. O mapeamento UV aplicará sua arte no modelo 3D à direita instantaneamente.
                </div>
            </div>

            <!-- PREVIEW 3D -->
            <!-- w-full no mobile, w-1/2 no desktop. Altura fixa no mobile (50vh), full no desktop -->
            <div class="w-full lg:w-1/2 h-[50vh] lg:h-auto p-4 flex flex-col bg-black relative shrink-0">
                <div class="absolute top-4 right-4 md:top-8 md:right-8 z-10 bg-black/50 text-white px-3 py-1 rounded text-xs font-mono backdrop-blur-sm border border-white/10 pointer-events-none">
                    WEBGL PREVIEW
                </div>
                <div id="loadingMsg" class="hidden absolute inset-0 z-20 bg-black/80 flex items-center justify-center text-white font-mono">
                    Carregando Modelo...
                </div>
                <div id="threeContainer" class="w-full h-full rounded-lg overflow-hidden border border-zinc-800 relative shadow-inner"></div>
                
                <div class="h-8 flex items-center justify-center gap-2 md:gap-4 text-zinc-600 text-[10px] md:text-xs mt-2 font-mono">
                    <span>Rotacionar: 1 Dedo</span> | <span>Zoom: Pinça</span>
                </div>
            </div>

        </main>
    </div>

    <!-- SCRIPT PRINCIPAL -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // ==========================================
        // ESTADO GLOBAL
        // ==========================================
        const state = {
            brushColor: '#ff0000',
            brushSize: 20,
            isEraser: false,
            wear: 0.05,
            currentWeapon: 'ak47'
        };

        // ==========================================
        // LÓGICA DO CANVAS 2D
        // ==========================================
        const canvas = document.getElementById('textureCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Inicialização do Canvas
        function initCanvas() {
            // Fundo escuro (Primer)
            ctx.fillStyle = '#2b2b2b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Guias UV (Simuladas)
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            
            // Guia do Corpo
            ctx.strokeRect(50, 50, 924, 400); 
            
            // Guia da Coronha/Grip
            ctx.strokeRect(50, 500, 400, 400);

            // Textos de Guia
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = '#3f3f46';
            ctx.textAlign = 'center';
            ctx.fillText('ÁREA PRINCIPAL (Corpo/Slide)', 512, 250);
            ctx.fillText('GRIP / CORONHA', 250, 700);
            ctx.fillText('DETALHES', 700, 700);
        }
        initCanvas();

        // Desenho
        let isDrawing = false;
        
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // Suporte para touch ou mouse
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // Eventos Mouse e Touch unificados para suporte mobile
        function startDraw(e) {
            if (e.touches && e.touches.length > 1) return; // Ignora pinch zoom
            if (e.cancelable) e.preventDefault(); // Evita scroll ao desenhar
            
            isDrawing = true;
            const pos = getMousePos(e);
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            draw(e);
        }

        function endDraw() {
            if(isDrawing) {
                isDrawing = false;
                ctx.beginPath();
                updateTexture();
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            // if (e.cancelable) e.preventDefault(); // Removido para testar scroll vs touch
            
            const pos = getMousePos(e);

            ctx.lineWidth = state.brushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (state.isEraser) {
                ctx.strokeStyle = '#2b2b2b'; 
            } else {
                ctx.strokeStyle = state.brushColor;
            }

            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
            
            updateTexture();
            
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
        }

        // Mouse Listeners
        canvas.addEventListener('mousedown', startDraw);
        window.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mousemove', draw);

        // Touch Listeners (Mobile)
        canvas.addEventListener('touchstart', startDraw, { passive: false });
        window.addEventListener('touchend', endDraw);
        canvas.addEventListener('touchmove', draw, { passive: false });

        // ==========================================
        // LÓGICA DO THREE.JS (3D)
        // ==========================================
        const container = document.getElementById('threeContainer');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#111111'); // Fundo quase preto

        // Câmera
        const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(4, 3, 5);

        // Renderizador
        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace; // Padrão moderno de cores
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Controles
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 15;

        // Iluminação
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        const fillLight = new THREE.DirectionalLight(0x88ccff, 0.4);
        fillLight.position.set(-5, 2, -5);
        scene.add(fillLight);

        // Textura Dinâmica
        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.flipY = false; // Importante para UVs de jogos

        function updateTexture() {
            texture.needsUpdate = true;
        }

        // Material da Arma
        const material = new THREE.MeshStandardMaterial({
            map: texture,
            roughness: 0.5,
            metalness: 0.6,
            color: 0xffffff,
            side: THREE.DoubleSide
        });

        // Grupo principal da arma
        let weaponGroup = new THREE.Group();
        scene.add(weaponGroup);

        // ------------------------------------------
        // GERADORES DE ARMAS (PROCEDURAL)
        // ------------------------------------------
        
        // AK-47
        function generateAK47() {
            // Corpo Central
            const bodyGeo = new THREE.BoxGeometry(3, 0.7, 0.5);
            const bodyMesh = new THREE.Mesh(bodyGeo, material);
            bodyMesh.castShadow = true;
            weaponGroup.add(bodyMesh);

            // Coronha
            const stockGeo = new THREE.BoxGeometry(1.5, 0.6, 0.3);
            const stockMesh = new THREE.Mesh(stockGeo, material);
            stockMesh.position.set(-2.1, -0.3, 0);
            stockMesh.rotation.z = -0.2;
            stockMesh.castShadow = true;
            weaponGroup.add(stockMesh);

            // Cano
            const barrelGeo = new THREE.CylinderGeometry(0.06, 0.06, 2.2, 16);
            const barrelMesh = new THREE.Mesh(barrelGeo, material);
            barrelMesh.rotation.z = -Math.PI / 2;
            barrelMesh.position.set(2.6, 0.1, 0);
            weaponGroup.add(barrelMesh);

            // Tubo de Gás
            const gasGeo = new THREE.CylinderGeometry(0.08, 0.08, 1.5, 16);
            const gasMesh = new THREE.Mesh(gasGeo, material);
            gasMesh.rotation.z = -Math.PI / 2;
            gasMesh.position.set(2.2, 0.3, 0);
            weaponGroup.add(gasMesh);

            // Magazine (Curvado)
            const magGeo = new THREE.BoxGeometry(0.6, 1.5, 0.35);
            const magMesh = new THREE.Mesh(magGeo, material);
            magMesh.position.set(0.8, -0.9, 0);
            magMesh.rotation.z = 0.4;
            magMesh.castShadow = true;
            weaponGroup.add(magMesh);

            // Grip
            const gripGeo = new THREE.BoxGeometry(0.4, 0.8, 0.3);
            const gripMesh = new THREE.Mesh(gripGeo, material);
            gripMesh.position.set(-0.8, -0.6, 0);
            gripMesh.rotation.z = -0.3;
            weaponGroup.add(gripMesh);
        }

        // M4A1-S
        function generateM4A1S() {
            // Corpo (Mais retangular)
            const bodyGeo = new THREE.BoxGeometry(2.8, 0.65, 0.45);
            const bodyMesh = new THREE.Mesh(bodyGeo, material);
            bodyMesh.castShadow = true;
            weaponGroup.add(bodyMesh);

            // Coronha (Tubo e apoio)
            const stockTubeGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 16);
            const stockTube = new THREE.Mesh(stockTubeGeo, material);
            stockTube.rotation.z = -Math.PI / 2;
            stockTube.position.set(-2.0, 0, 0);
            weaponGroup.add(stockTube);

            const stockEndGeo = new THREE.BoxGeometry(0.4, 1.0, 0.3);
            const stockEnd = new THREE.Mesh(stockEndGeo, material);
            stockEnd.position.set(-2.7, -0.2, 0);
            weaponGroup.add(stockEnd);

            // Handguard
            const handguardGeo = new THREE.CylinderGeometry(0.25, 0.25, 1.8, 8);
            const handguard = new THREE.Mesh(handguardGeo, material);
            handguard.rotation.z = -Math.PI / 2;
            handguard.position.set(2.2, 0, 0);
            weaponGroup.add(handguard);

            // Silenciador (Característica principal)
            const silencerGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.8, 16);
            const silencer = new THREE.Mesh(silencerGeo, material);
            silencer.rotation.z = -Math.PI / 2;
            silencer.position.set(4.0, 0, 0);
            weaponGroup.add(silencer);

            // Magazine (Reto)
            const magGeo = new THREE.BoxGeometry(0.7, 1.2, 0.35);
            const magMesh = new THREE.Mesh(magGeo, material);
            magMesh.position.set(0.5, -0.8, 0);
            magMesh.rotation.z = 0.1;
            weaponGroup.add(magMesh);

            // Grip
            const gripGeo = new THREE.BoxGeometry(0.4, 0.8, 0.3);
            const gripMesh = new THREE.Mesh(gripGeo, material);
            gripMesh.position.set(-0.8, -0.6, 0);
            gripMesh.rotation.z = -0.3;
            weaponGroup.add(gripMesh);
            
            // Carry Handle / Sight base
            const sightGeo = new THREE.BoxGeometry(1.5, 0.3, 0.2);
            const sight = new THREE.Mesh(sightGeo, material);
            sight.position.set(0.5, 0.45, 0);
            weaponGroup.add(sight);
        }

        // AWP
        function generateAWP() {
             // Corpo
             const bodyGeo = new THREE.BoxGeometry(3.5, 0.8, 0.5);
             const bodyMesh = new THREE.Mesh(bodyGeo, material);
             bodyMesh.castShadow = true;
             weaponGroup.add(bodyMesh);

             // Cano Longo
             const barrelGeo = new THREE.CylinderGeometry(0.1, 0.12, 4, 16);
             const barrel = new THREE.Mesh(barrelGeo, material);
             barrel.rotation.z = -Math.PI / 2;
             barrel.position.set(3.5, 0.1, 0);
             weaponGroup.add(barrel);

             // Luneta (Scope)
             const scopeTubeGeo = new THREE.CylinderGeometry(0.25, 0.3, 1.5, 16);
             const scope = new THREE.Mesh(scopeTubeGeo, material);
             scope.rotation.z = -Math.PI / 2;
             scope.position.set(0.5, 0.8, 0);
             weaponGroup.add(scope);
             
             // Suporte Luneta
             const mountGeo = new THREE.BoxGeometry(0.5, 0.4, 0.2);
             const mount = new THREE.Mesh(mountGeo, material);
             mount.position.set(0.5, 0.5, 0);
             weaponGroup.add(mount);

             // Coronha Thumbhole
             const stockGeo = new THREE.BoxGeometry(2, 0.8, 0.5);
             const stock = new THREE.Mesh(stockGeo, material);
             stock.position.set(-2.5, -0.2, 0);
             weaponGroup.add(stock);

             // Bipé (Fechado)
             const bipodGeo = new THREE.BoxGeometry(1.2, 0.15, 0.3);
             const bipod = new THREE.Mesh(bipodGeo, material);
             bipod.position.set(3, -0.4, 0);
             weaponGroup.add(bipod);
        }

        // Glock
        function generateGlock() {
            // Slide (Topo)
            const slideGeo = new THREE.BoxGeometry(2.2, 0.5, 0.45);
            const slide = new THREE.Mesh(slideGeo, material);
            slide.position.set(0, 0.5, 0);
            slide.castShadow = true;
            weaponGroup.add(slide);

            // Frame / Grip
            const gripGeo = new THREE.BoxGeometry(0.5, 1.2, 0.42);
            const grip = new THREE.Mesh(gripGeo, material);
            grip.position.set(-0.6, -0.2, 0);
            grip.rotation.z = -0.15;
            weaponGroup.add(grip);

            // Trigger Guard
            const guardGeo = new THREE.TorusGeometry(0.2, 0.05, 8, 16, Math.PI);
            const guard = new THREE.Mesh(guardGeo, material);
            guard.position.set(0.1, 0, 0);
            guard.rotation.z = Math.PI;
            weaponGroup.add(guard);
        }

        // Desert Eagle
        function generateDeagle() {
            // Cano Triangular (Característico)
            const barrelGeo = new THREE.CylinderGeometry(0.3, 0.35, 2.0, 3); // Prisma triangular
            const barrel = new THREE.Mesh(barrelGeo, material);
            barrel.rotation.z = -Math.PI / 2;
            barrel.rotation.x = -Math.PI / 6; // Ajuste para o triângulo ficar plano em cima
            barrel.position.set(1.0, 0.5, 0);
            barrel.castShadow = true;
            weaponGroup.add(barrel);

            // Corpo Traseiro
            const bodyGeo = new THREE.BoxGeometry(1.2, 0.6, 0.5);
            const body = new THREE.Mesh(bodyGeo, material);
            body.position.set(-0.5, 0.5, 0);
            weaponGroup.add(body);

            // Grip Grande
            const gripGeo = new THREE.BoxGeometry(0.65, 1.4, 0.48);
            const grip = new THREE.Mesh(gripGeo, material);
            grip.position.set(-0.8, -0.3, 0);
            grip.rotation.z = -0.2;
            weaponGroup.add(grip);
            
            // Martelo (Hammer)
            const hammerGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.2, 16);
            const hammer = new THREE.Mesh(hammerGeo, material);
            hammer.rotation.x = Math.PI / 2;
            hammer.position.set(-1.2, 0.7, 0);
            weaponGroup.add(hammer);
        }

        // Função Principal de Geração
        function createWeaponModel(type) {
            // Limpa grupo
            while(weaponGroup.children.length > 0){ 
                weaponGroup.remove(weaponGroup.children[0]); 
            }
            
            // Reseta posição/rotação do grupo
            weaponGroup.position.set(0, 0, 0);
            weaponGroup.rotation.set(0, 0, 0);
            weaponGroup.scale.set(1, 1, 1);

            switch(type) {
                case 'ak47':
                    generateAK47();
                    break;
                case 'm4a1s':
                    generateM4A1S();
                    break;
                case 'awp':
                    generateAWP();
                    break;
                case 'glock':
                    generateGlock();
                    break;
                case 'deagle':
                    generateDeagle();
                    break;
                default:
                    generateAK47();
            }
        }

        // Event Listener para o Seletor
        const weaponSelect = document.getElementById('weaponSelect');
        const weaponLabel = document.getElementById('weaponLabel');

        weaponSelect.addEventListener('change', (e) => {
            state.currentWeapon = e.target.value;
            createWeaponModel(state.currentWeapon);
            
            // Atualiza Header
            const name = e.target.options[e.target.selectedIndex].text;
            weaponLabel.textContent = name;

            // Limpa canvas ao mudar arma (opcional, mas bom pra UX)
            // Se preferir manter o desenho, comente as linhas abaixo:
            ctx.fillStyle = '#2b2b2b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            initCanvas(); // Redesenha guias
            updateTexture();
        });

        // Inicia com AK-47
        createWeaponModel('ak47');

        // ------------------------------------------
        // CARREGADOR DE MODELOS .OBJ E .GLTF
        // ------------------------------------------
        const objLoader = new OBJLoader();
        const gltfLoader = new GLTFLoader();
        const fileInput = document.getElementById('fileInput');
        const loadingMsg = document.getElementById('loadingMsg');

        // Função auxiliar para processar o objeto carregado
        function handleLoadedModel(object) {
            while(weaponGroup.children.length > 0){ 
                weaponGroup.remove(weaponGroup.children[0]); 
            }
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 5 / maxDim;

            object.traverse((child) => {
                if (child.isMesh) {
                    child.material = material; 
                    child.castShadow = true;
                    child.receiveShadow = true;
                    child.geometry.computeVertexNormals();
                }
            });

            object.position.sub(center); 
            object.scale.multiplyScalar(scale); 
            weaponGroup.add(object);
            
            weaponLabel.textContent = "Modelo Customizado";
            alert('Modelo carregado com sucesso!');
            loadingMsg.classList.add('hidden');
        }

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            loadingMsg.classList.remove('hidden');
            const extension = file.name.split('.').pop().toLowerCase();
            const reader = new FileReader();

            reader.onload = function(e) {
                const contents = e.target.result;
                try {
                    if (extension === 'obj') {
                        // .OBJ (Texto)
                        const object = objLoader.parse(contents);
                        handleLoadedModel(object);
                    } else if (extension === 'gltf' || extension === 'glb') {
                        // .GLTF / .GLB (ArrayBuffer)
                        gltfLoader.parse(contents, '', (gltf) => {
                            handleLoadedModel(gltf.scene);
                        }, (err) => {
                            throw err;
                        });
                    } else {
                        throw new Error('Formato não suportado: ' + extension);
                    }
                } catch (err) {
                    alert('Erro ao carregar modelo: ' + err.message);
                    loadingMsg.classList.add('hidden');
                }
            };

            // Lógica de leitura baseada na extensão
            if (extension === 'obj' || extension === 'gltf') {
                reader.readAsText(file); // GLTF JSON pode ser lido como texto, mas GLLoader aceita buffer também
            } else {
                reader.readAsArrayBuffer(file); // GLB deve ser ArrayBuffer
            }
        });

        // Função para atualizar propriedades do material (Desgaste)
        function updateMaterialWear() {
            material.roughness = 0.4 + (state.wear * 0.4);
            material.metalness = 0.6 - (state.wear * 0.3);
        }

        // Animação Loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            const width = container.clientWidth;
            const height = container.clientHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

        // ==========================================
        // UI HANDLERS (Resto do código igual)
        // ==========================================
        
        // Botões de Ferramenta
        const btnBrush = document.getElementById('btnBrush');
        const btnEraser = document.getElementById('btnEraser');

        function updateToolUI() {
            if (state.isEraser) {
                btnEraser.classList.replace('bg-zinc-800', 'bg-red-600');
                btnEraser.classList.replace('text-zinc-200', 'text-white');
                btnBrush.classList.replace('bg-yellow-600', 'bg-zinc-800');
                btnBrush.classList.replace('text-white', 'text-zinc-200');
            } else {
                btnBrush.classList.replace('bg-zinc-800', 'bg-yellow-600');
                btnBrush.classList.replace('text-zinc-200', 'text-white');
                btnEraser.classList.replace('bg-red-600', 'bg-zinc-800');
                btnEraser.classList.replace('text-white', 'text-zinc-200');
            }
        }

        btnBrush.addEventListener('click', () => { state.isEraser = false; updateToolUI(); });
        btnEraser.addEventListener('click', () => { state.isEraser = true; updateToolUI(); });

        // Cor
        const colorPicker = document.getElementById('colorPicker');
        const colorPresets = document.querySelectorAll('.color-preset');

        colorPicker.addEventListener('input', (e) => {
            state.brushColor = e.target.value;
            state.isEraser = false;
            updateToolUI();
        });

        colorPresets.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const color = e.target.getAttribute('data-color');
                state.brushColor = color;
                colorPicker.value = color;
                state.isEraser = false;
                updateToolUI();
            });
        });

        // Tamanho
        const sizeSlider = document.getElementById('sizeSlider');
        const sizeValue = document.getElementById('sizeValue');

        sizeSlider.addEventListener('input', (e) => {
            state.brushSize = parseInt(e.target.value);
            sizeValue.textContent = state.brushSize + 'px';
        });

        // Wear
        const wearSlider = document.getElementById('wearSlider');
        const wearValue = document.getElementById('wearValue');

        wearSlider.addEventListener('input', (e) => {
            state.wear = parseFloat(e.target.value);
            wearValue.textContent = state.wear.toFixed(2);
            updateMaterialWear();
        });

        // Export
        document.getElementById('btnExport').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'cs2_skin_texture.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            alert('Textura exportada com sucesso!\nEsta imagem está pronta para ser usada como "Albedo Map" no CS2 Workshop Tools.');
        });

    </script>
</body>
</html>